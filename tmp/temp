# d61864_genai/logging/logging_config.py
import logging
import os
import sys
from logging.handlers import RotatingFileHandler
from pathlib import Path
from typing import Optional

DEFAULT_SERVICE_NAME = "d61864_genai"
DEFAULT_MAX_BYTES = 10 * 1024 * 1024  # 10 MB
DEFAULT_BACKUP_COUNT = 5


def setup_logging(
    service_name: Optional[str] = None,
    log_base_dir: Optional[str] = None,
    max_bytes: int = DEFAULT_MAX_BYTES,
    backup_count: int = DEFAULT_BACKUP_COUNT,
    level: Optional[int] = None,
) -> logging.Logger:
    """
    Initialize and return an SDK logger for the given service_name.

    Behavior:
    - If the application's root logger already has handlers, we don't override global handlers.
      We still create/configure a scoped logger for the SDK (service_name).
    - If log_base_dir is provided, add rotating file handlers under <log_base_dir>/<service_name>/.
    - Otherwise, add a StreamHandler to stdout (suitable for dev & containers).
    - Silences noisy third-party libraries.

    Returns the configured logger instance (logging.getLogger(service_name)).
    """

    service_name = service_name or os.getenv("SDK_SERVICE_NAME", DEFAULT_SERVICE_NAME)
    log_dir_env = log_base_dir or os.getenv("SDK_LOG_BASE_DIR", "")
    # If user sets empty string or None, we use stdout

    # Choose level: prefer explicit param -> env -> INFO
    if level is None:
        env_level = os.getenv("SDK_LOG_LEVEL", "").upper()
        if env_level:
            level = getattr(logging, env_level, logging.INFO)
        else:
            level = logging.DEBUG if os.getenv("APP_ENV", "dev").lower() == "dev" else logging.INFO

    # Formatter
    fmt = os.getenv(
        "SDK_LOG_FORMAT",
        "%(asctime)s | %(levelname)s | %(name)s | %(message)s"
    )
    datefmt = os.getenv("SDK_LOG_DATEFMT", "%Y-%m-%d %H:%M:%S")
    formatter = logging.Formatter(fmt=fmt, datefmt=datefmt)

    # Create or get the named logger for the SDK
    logger = logging.getLogger(service_name)
    logger.setLevel(level)

    # If app root already has handlers, don't modify root; but configure service logger
    root = logging.getLogger()
    root_has_handlers = bool(root.handlers)

    # Clear existing handlers for our service logger (avoid duplicates on repeated init)
    # BUT do not clear root handlers.
    logger.handlers.clear()

    if log_dir_env:
        # safe directory creation
        base = Path(log_dir_env) / service_name
        base.mkdir(parents=True, exist_ok=True)

        app_log_path = base / "app.log"
        err_log_path = base / "error.log"

        app_handler = RotatingFileHandler(
            filename=str(app_log_path),
            maxBytes=max_bytes,
            backupCount=backup_count,
            encoding="utf-8",
        )
        app_handler.setFormatter(formatter)
        app_handler.setLevel(level)

        err_handler = RotatingFileHandler(
            filename=str(err_log_path),
            maxBytes=max_bytes,
            backupCount=backup_count,
            encoding="utf-8",
        )
        err_handler.setFormatter(formatter)
        err_handler.setLevel(logging.ERROR)

        logger.addHandler(app_handler)
        logger.addHandler(err_handler)

    else:
        # Stream to stdout; if root has handlers we still add a handler scoped to service logger
        stream_handler = logging.StreamHandler(sys.stdout)
        stream_handler.setFormatter(formatter)
        stream_handler.setLevel(level)
        logger.addHandler(stream_handler)

    # Prevent double propagation if the root handlers exist and you don't want duplication
    # If root has handlers we keep propagate=False so messages don't duplicate to root handlers by default.
    logger.propagate = False if root_has_handlers else True

    # Silence noisy third-party libraries that are known to be verbose
    noisy_libs = [
        "urllib3",
        "requests",
        "azure",
        "azure.identity",
        "azure.core",
        "azure.core.pipeline",
        "azure.core.pipeline.policies.http_logging_policy",
        "msal",
        "presidio",
        "presidio_analyzer",
        "werkzeug",
    ]
    for lib in noisy_libs:
        lib_logger = logging.getLogger(lib)
        lib_logger.setLevel(logging.WARNING)
        lib_logger.propagate = False

    return logger